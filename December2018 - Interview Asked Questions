Interview asked questins-

1. A list of most important features of Java language is given below.

Java Features
Simple
Object-Oriented
Portable
Platform independent
Secured
Robust
Architecture neutral
Interpreted
High Performance
Multithreaded
Distributed
Dynamic

Simple
Java is very easy to learn, and its syntax is simple, clean and easy to understand. 

Platform Independent
Java code can be run on multiple platforms, for example, Windows, Linux, Sun Solaris, Mac/OS, etc. 
Java code is compiled by the compiler and converted into bytecode. This bytecode is a platform-independent code because 
it can be run on multiple platforms, i.e., Write Once and Run Anywhere(WORA).

Portable
Java is portable because it facilitates you to carry the Java bytecode to any platform. 
It doesn't require any implementation.


2. Basic concepts of OOPs are:

Object
Class
Inheritance
Polymorphism
Abstraction
Encapsulation

Polymorphism - in Java is a concept by which we can perform a single action in different ways.
The word "poly" means many and "morphs" means forms. So polymorphism means many forms.

There are two types of polymorphism in Java: compile-time polymorphism and runtime polymorphism. 
We can perform polymorphism in java by method overloading and method overriding.


3. Can i declare a static variable inside static member function in Java. like bellow?
	e.g
	private static int Fibonoci(int n) {
	static int first=0;
	static int second=1;
	static int sum;
	if(n>0)
i am getting a error "Illegal Modifier" and if i remove static keyword there is no error and i need those variables to be static

Ans - You can not declare varibale as static inside a method. 
Inside method all variables are local variables that has no existance outside this method thats why they cann't be static.
The Root cause: Static Variables are allocated memory at class loading time because they are part of the class and not its object.



4. can you override the main method in Java?
Ans - The answer is No because main is a static method and static method cannot be overridden in Java.


5. can you overload the main method in Java?
Ans - Yes

e.g- overload the main method
package com.lara;
//Java Program to show that we can overload main method in Java but we cannot override main method.
 public class Overload_Main_Method {
	//Standard main method, JVM will only call this method even if we provided multiple overloaded version.
	public static void main(String[] args) {
		System.out.println("Inside main(String[] args) method ....");
	}
	
	public static void main(Integer[] args) {
		System.out.println("Inside main(Integer[] args) method ....");
	}
	
	public static void main(Double[] args) {
		System.out.println("Inside main(Double[] args) method ....");
	}
}


6. Can we run a Java program without main method?
Ans - Many Java programmer gives you answer that they can run Java program without main method by writing code in static initializer 
block, which is half true. Yes, code written in static initializer block is executed before calling main method, but you won't be 
able to run a class by using Java command, or Eclipse or anything else, until it got  public static void main(String args[]) method 
on it. If you try to run such programs, you will get following error :

Error: Main method not found in class JavaAppWithoutMain, please define the main
method as:   public static void main(String[] args)


7. Can we make main final in Java?
Ans - Yes, We can make the main method final in Java. JVM has no issue with that. Unlike any final method, 
you can not override main in Java.

Exception handling-
8. Question 3. Is it valid to write try block without catch block?
class ExceptionExample {

 public static void main(String[] args) {
  System.out.println("Value of a :"+test());
 }
 
 private static int test(){
  int a = 10;
  try {
   return a;
  }finally{
   return a;
  }
 }
}

Output:  
Value of a :10
 
Yes. It is perfectly valid to write try block without catch block.
Rule: 
1. After try block, there can be direct finally block. OR
2. After try block, there can be direct catch block.

Note: Only try block without catch or finally is compile time error. 


9. Differece between Compile time and Run time Error 

Compile time- 
What can go wrong at compile time:

Syntax errors
Type checking errors
compiler crashes

Run time-
What can go wrong are run-time errors:

Division by zero
Dereferencing a null pointer
Running out of memory

Also there can be errors that are detected by the program itself:
Trying to open a file that isn't there
Trying find a web page and discovering that an alleged URL is not well formed


10. Let's see the code to check the performance of String, StringBuffer and StringBuilder classes.

package com.lara;
public class Performance_Of_String_StringBuffer_StringBuilder {
	public static void main(String[] args) {		
	//String  no.3 performance(Very Bad. Because it's take so much time to concatenate)
	Long startTime=System.currentTimeMillis();
	String t = "Java";
	for(int i=1; i<=1000; i++)
	{
		t=t.concat("Tpoint");
	}
	System.out.println("Time taken by Concating with String: "+ (System.currentTimeMillis()- startTime));
		
	//StringBuffer no.2 performance because it's syncronized
	startTime = System.currentTimeMillis();  
        StringBuffer sb = new StringBuffer("Java");  
        for (int i=0; i<10000; i++){  
            sb.append("Tpoint");  
        }  
        System.out.println("Time taken by StringBuffer: " + (System.currentTimeMillis() - startTime) + "ms");
        
        //StringBuilder no.1 performance
        startTime = System.currentTimeMillis();  
        StringBuilder sb2 = new StringBuilder("Java");  
        for (int i=0; i<10000; i++){  
            sb2.append("Tpoint");  
        }  
        System.out.println("Time taken by StringBuilder: " + (System.currentTimeMillis() - startTime) + "ms");  
	}

}

Output-
Time taken by Concating with String: 8ms
Time taken by StringBuffer: 3ms
Time taken by StringBuilder: 2ms
